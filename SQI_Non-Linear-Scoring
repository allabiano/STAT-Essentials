# Make sure you have these packages installed:
# install.packages(c("shiny", "shinydashboard", "readr", "dplyr", "FactoMineR", "ggplot2", "DT", "forcats", "tibble", "tidyr", "factoextra", "writexl", "ggcorrplot"))

library(shiny)
library(shinydashboard)
library(readr)
library(dplyr)
library(FactoMineR)
library(ggplot2)
library(DT)
library(forcats)
library(tibble)
library(tidyr)
library(factoextra)
library(writexl)
library(ggcorrplot)

# --- Helper Functions based on the paper's specific NL forms ---

# Non-linear "More is Better" sigmoid scoring function (Type I from paper)
score_more_is_better <- function(x, x0, b = 2.5) {
  1 / (1 + exp(-b * (x - x0)))
}

# Non-linear "Less is Better" sigmoid scoring function (Type II from paper)
score_less_is_better <- function(x, x0, b = 2.5) {
  1 / (1 + exp(b * (x - x0)))
}

# Non-linear "Optimum Range" (Type III from paper - Gaussian-like for illustration)
score_optimum_range <- function(x, opt_val, width) {
  exp(-((x - opt_val)^2) / (2 * width^2))
}


# --- UI Definition ---
ui <- dashboardPage(
  dashboardHeader(title = "Soil Quality Index (SQI) App - PCA & Non-Linear Scoring"),
  dashboardSidebar(
    sidebarMenu(
      menuItem("Data Upload", tabName = "data_upload", icon = icon("upload")),
      menuItem("PCA & MDS Selection", tabName = "pca_mds", icon = icon("chart-bar")),
      menuItem("Scoring & SQI Calculation", tabName = "scoring_sqi", icon = icon("calculator")),
      menuItem("Results", tabName = "results", icon = icon("table"))
    )
  ),
  dashboardBody(
    tabItems(
      # Data Upload Tab
      tabItem(tabName = "data_upload",
              h2("Upload Your Soil Data"),
              fluidRow(
                box(
                  title = "Instructions", status = "primary", solidHeader = TRUE,
                  width = 12,
                  p("1. Upload a CSV file with your soil property data."),
                  p("2. Each column should represent a soil property (e.g., pH, Organic Carbon, Bulk Density)."),
                  p("3. Each row should represent a soil sample."),
                  p("4. Ensure column names are unique and descriptive.")
                ),
                box(
                  title = "File Input", status = "info", solidHeader = TRUE,
                  width = 6,
                  fileInput("file1", "Choose CSV File",
                            multiple = FALSE,
                            accept = c("text/csv",
                                       "text/comma-separated-values,text/plain",
                                       ".csv")),
                  checkboxInput("header", "Header", TRUE),
                  radioButtons("sep", "Separator",
                               choices = c(Comma = ",",
                                           Semicolon = ";",
                                           Tab = "\t"),
                               selected = ",")
                ),
                box(
                  title = "Uploaded Data Preview", status = "info", solidHeader = TRUE,
                  width = 6,
                  DTOutput("data_preview")
                )
              )
      ),
      
      # PCA & MDS Selection Tab
      tabItem(tabName = "pca_mds",
              h2("Principal Component Analysis & Minimum Data Set (MDS) Selection"),
              fluidRow(
                box(
                  title = "PCA Configuration", status = "primary", solidHeader = TRUE,
                  width = 4,
                  p("Click 'Run PCA' to analyze your data and identify significant components."),
                  actionButton("run_pca", "Run PCA", icon = icon("play")),
                  hr(),
                  h4("MDS Indicator Selection"),
                  p("Select MDS indicators from the variables with high loadings on PCs with Eigenvalue ≥ 1. The app suggests variables with the highest absolute loading per PC."),
                  uiOutput("mds_selection_ui") # Dynamic UI for MDS selection
                ),
                box(
                  title = "Scree Plot (Eigenvalues of Principal Components)", status = "info", solidHeader = TRUE,
                  width = 8,
                  plotOutput("scree_plot")
                ),
                box(
                  title = "PCA Summary Statistics", status = "info", solidHeader = TRUE,
                  width = 12,
                  p("This table shows the eigenvalues and the proportion of variance explained by each principal component."),
                  DTOutput("pca_summary_table"),
                  downloadButton("download_pca_summary", "Download PCA Summary (.xlsx)")
                ),
                box(
                  title = "Correlation Matrix of Soil Properties", status = "info", solidHeader = TRUE,
                  width = 8,
                  p("This plot shows the linear relationships between all numeric variables. A circle's size and color intensity indicate the strength of the correlation."),
                  plotOutput("correlation_plot")
                ),
                box(
                  title = "PCA Loadings Table (Variables and their contributions to PCs)", status = "info", solidHeader = TRUE,
                  width = 12,
                  p("PCs with Eigenvalue ≥ 1 are considered significant. Identify variables with high absolute loadings within these PCs."),
                  DTOutput("pca_loadings_table"),
                  downloadButton("download_pca_loadings", "Download PCA Loadings Table (.xlsx)")
                )
              )
      ),
      
      # Scoring & SQI Tab
      tabItem(tabName = "scoring_sqi",
              h2("Define Non-Linear Scoring Functions and Calculate SQI"),
              fluidRow(
                box(
                  title = "Scoring Parameters for MDS Indicators", status = "primary", solidHeader = TRUE,
                  width = 12,
                  p("For each selected MDS indicator, choose a scoring function type and define its parameters."),
                  uiOutput("scoring_params_ui"), # Dynamic UI for scoring parameters
                  hr(),
                  DTOutput("scoring_summary_table"),
                  downloadButton("download_scoring_summary", "Download Scoring Summary (.xlsx)"),
                  hr(),
                  actionButton("calculate_sqi", "Calculate Soil Quality Index", icon = icon("cogs"))
                )
              )
      ),
      
      # Results Tab
      tabItem(tabName = "results",
              h2("Soil Quality Index Results"),
              fluidRow(
                box(
                  title = "Calculated SQI Values and Individual Scores", status = "success", solidHeader = TRUE,
                  width = 12,
                  DTOutput("sqi_results_table"),
                  downloadButton("download_sqi", "Download SQI Results")
                ),
                box(
                  title = "SQI Distribution", status = "success", solidHeader = TRUE,
                  width = 6,
                  plotOutput("sqi_histogram_plot")
                ),
                box(
                  title = "MDS Weights Used", status = "success", solidHeader = TRUE,
                  width = 6,
                  DTOutput("mds_weights_table"),
                  downloadButton("download_mds_weights", "Download MDS Weights (.xlsx)")
                )
              ),
              fluidRow( # New row for the grouping variable selection and bar graph
                box(
                  title = "Grouped SQI Bar Graph", status = "info", solidHeader = TRUE,
                  width = 12,
                  uiOutput("grouping_variable_selector_ui"), # Dropdown for grouping variable
                  plotOutput("sqi_group_bar_plot")
                ),
                box(
                  title = "Summary of Grouped SQI Results", status = "info", solidHeader = TRUE,
                  width = 12,
                  p("This table provides a statistical summary (N, Mean, SD) of the SQI for each group."),
                  DTOutput("sqi_group_summary_table")
                )
              )
      )
    )
  )
)

# --- Server Logic ---
server <- function(input, output, session) {
  
  # Reactive for uploaded data
  data_raw <- reactive({
    req(input$file1)
    df <- read.csv(input$file1$datapath, header = input$header, sep = input$sep)
    
    # Check if there are any numeric columns for PCA
    df_numeric_check <- df %>% select(where(is.numeric))
    if(ncol(df_numeric_check) == 0) {
      showNotification("No numeric columns found in the uploaded file for PCA. Please check your data.", type = "error")
      return(NULL)
    }
    df # Return original for later merging with scores
  })
  
  # Reactive for numeric data for PCA, Correlation etc.
  data_numeric <- reactive({
    req(data_raw())
    df_numeric <- data_raw() %>% select(where(is.numeric))
    if(ncol(df_numeric) == 0) return(NULL)
    df_numeric
  })
  
  # Display data preview
  output$data_preview <- renderDT({
    data_raw()
  }, options = list(pageLength = 5))
  
  # Reactive for normalized data (for PCA)
  normalized_data <- eventReactive(input$run_pca, {
    req(data_numeric())
    scale(data_numeric(), center = TRUE, scale = TRUE) # Z-score normalization
  })
  
  # Reactive for PCA results
  pca_results <- eventReactive(input$run_pca, {
    req(normalized_data())
    PCA(normalized_data(), graph = FALSE)
  })
  
  # Reactive for Correlation Matrix
  correlation_matrix <- eventReactive(input$run_pca, {
    req(data_numeric())
    data_cor <- data_numeric()
    cor_matrix <- cor(data_cor, use = "complete.obs")
    p_matrix <- cor_pmat(data_cor, use = "complete.obs")
    list(cor = cor_matrix, p = p_matrix)
  })
  
  # Render Correlation Plot
  output$correlation_plot <- renderPlot({
    req(correlation_matrix())
    cor_data <- correlation_matrix()
    ggcorrplot(cor_data$cor,
               hc.order = TRUE,
               type = "lower", # Keep as "lower" for a half-matrix plot
               lab = TRUE,
               outline.col = "white",
               lab_size = 3,
               p.mat = cor_data$p,
               insig = "blank",
               ggtheme = ggplot2::theme_classic(),
               title = "",
               legend.title = "Correlation\nCoefficient") + 
    
    # Customization using ggplot2::theme()
    ggplot2::theme(
      legend.position = "bottom", 
      legend.title = element_blank(),
      legend.text = element_text(size = 9, family = "Times New Roman"),
      axis.text = element_text(size = 9, family = "Times New Roman"),
      legend.key.width = unit(2, "cm") # You can adjust this value as needed
    )
  })
  
  # Reactive for PCA Summary Table
  pca_summary_table <- reactive({
    req(pca_results())
    res_pca <- pca_results()
    eigenvalues <- as.data.frame(res_pca$eig)
    eigenvalues <- rownames_to_column(eigenvalues, var = "Principal Component")
    colnames(eigenvalues) <- c("Principal Component", "Eigenvalue", "% of Variance", "Cumulative % of Variance")
    eigenvalues
  })
  
  # Render PCA Summary Table
  output$pca_summary_table <- renderDT({
    req(pca_summary_table())
    datatable(pca_summary_table(), options = list(dom = 't', pageLength = 5))
  })
  
  # Filtered PCA loadings (only for PCs with eigenvalue >= 1)
  pca_loadings_filtered <- reactive({
    req(pca_results())
    res_pca <- pca_results()
    eigenvalues <- res_pca$eig[, "eigenvalue"]
    selected_pc_indices <- which(eigenvalues >= 1)
    
    if (length(selected_pc_indices) == 0) {
      return(data.frame(Variable = character(0), PC = character(0), Loading = numeric(0), stringsAsFactors = FALSE))
    }
    
    # Create the wide-format loadings data frame with PCs as columns
    loadings_df <- as.data.frame(res_pca$var$coord[, selected_pc_indices, drop = FALSE])
    colnames(loadings_df) <- paste0("PC", selected_pc_indices)
    
    # Identify the highest loading for each PC column
    is_significant_loading_matrix <- apply(loadings_df, 2, function(col) {
      abs(col) == max(abs(col), na.rm = TRUE)
    })
    
    # Add variables as a column and combine with the boolean matrix for styling
    final_df <- loadings_df %>%
      rownames_to_column(var = "Variable")
    
    list(
      data = final_df,
      styling_matrix = is_significant_loading_matrix,
      pc_columns = colnames(loadings_df)
    )
  })
  
  # Render Scree Plot
  output$scree_plot <- renderPlot({
    req(pca_results())
    fviz_eig(pca_results(), addlabels = TRUE, ylim = c(0, max(pca_results()$eig[, "eigenvalue"]) * 1.1))
  })
  
  # Render PCA Loadings Table with styling in landscape format
  output$pca_loadings_table <- renderDT({
    req(pca_loadings_filtered())
    data_to_display <- pca_loadings_filtered()$data
    styling_matrix <- pca_loadings_filtered()$styling_matrix
    pc_columns <- pca_loadings_filtered()$pc_columns
    
    # Create the DT table
    dt <- datatable(data_to_display,
                    options = list(pageLength = 15, dom = 'tip',
                                   scrollX = TRUE, # Enable horizontal scrolling
                                   columnDefs = list(list(targets = 0, className = 'dt-head-left'))))
    
    # Apply styling for each PC column
    for (i in 1:length(pc_columns)) {
      pc_col_name <- pc_columns[i]
      dt <- dt %>%
        formatStyle(
          columns = pc_col_name,
          valueColumns = list(pc_col_name),
          target = 'cell',
          fontWeight = styleEqual(c(TRUE), c('bold'), default = 'normal', data = list(styling_matrix[, i])),
          textDecoration = styleEqual(c(TRUE), c('underline'), default = 'none', data = list(styling_matrix[, i]))
        )
    }
    
    dt
  })
  
  # Download Handler for PCA Loadings Table (.xlsx)
  output$download_pca_loadings <- downloadHandler(
    filename = function() {
      paste("pca_loadings_table_", Sys.Date(), ".xlsx", sep = "")
    },
    content = function(file) {
      df_to_export <- pca_loadings_filtered()$data
      writexl::write_xlsx(df_to_export, path = file)
    }
  )
  
  # Download Handler for PCA Summary Statistics Table (.xlsx)
  output$download_pca_summary <- downloadHandler(
    filename = function() {
      paste("pca_summary_table_", Sys.Date(), ".xlsx", sep = "")
    },
    content = function(file) {
      writexl::write_xlsx(pca_summary_table(), path = file)
    }
  )
  
  # Dynamic UI for MDS selection (checkboxes)
  output$mds_selection_ui <- renderUI({
    req(pca_loadings_filtered())
    all_vars <- pca_loadings_filtered()$data$Variable
    
    if (length(all_vars) == 0) {
      return(p("No significant PCs (Eigenvalue ≥ 1) or variables found. Adjust your data or PCA parameters."))
    }
    
    # Pre-select top variable from each significant PC as a suggestion
    suggested_mds <- c()
    styling_matrix <- pca_loadings_filtered()$styling_matrix
    for (i in 1:ncol(styling_matrix)) {
      top_var_index <- which(styling_matrix[, i])
      if(length(top_var_index) > 0) {
        suggested_mds <- c(suggested_mds, all_vars[top_var_index])
      }
    }
    
    checkboxGroupInput("selected_mds_vars", "Select MDS Indicators:",
                       choices = all_vars,
                       selected = unique(suggested_mds))
  })
  
  # Reactive for selected MDS variables
  mds_vars_selected <- reactive({
    req(input$selected_mds_vars)
    input$selected_mds_vars
  })
  
  # --- NEW: Reactive for the scoring summary table ---
  scoring_summary_data <- reactive({
    req(mds_vars_selected())
    
    scoring_list <- lapply(mds_vars_selected(), function(var) {
      score_type <- input[[paste0("score_type_", var)]]
      if (is.null(score_type)) {
        return(NULL)
      }
      
      params <- switch(
        score_type,
        "more_is_better" = paste("x0:", input[[paste0("param_", var, "_x0")]], "; b:", input[[paste0("param_", var, "_b")]]),
        "less_is_better" = paste("x0:", input[[paste0("param_", var, "_x0")]], "; b:", input[[paste0("param_", var, "_b")]]),
        "optimum_range" = paste("Optimum Value:", input[[paste0("param_", var, "_opt_val")]], "; Width:", input[[paste0("param_", var, "_width")]]),
        "N/A"
      )
      
      data.frame(
        Indicator = var,
        `Scoring Function` = score_type,
        Parameters = params,
        check.names = FALSE
      )
    })
    
    if (length(scoring_list) > 0) {
      do.call(rbind, scoring_list)
    } else {
      data.frame(Indicator = character(0), `Scoring Function` = character(0), Parameters = character(0))
    }
  })
  
  # --- NEW: Render the scoring summary table ---
  output$scoring_summary_table <- renderDT({
    req(scoring_summary_data())
    datatable(scoring_summary_data(),
              options = list(
                dom = 't',
                pageLength = -1
              ))
  })
  
  # Download Handler for Scoring Summary Table
  output$download_scoring_summary <- downloadHandler(
    filename = function() {
      paste("scoring_summary_table_", Sys.Date(), ".xlsx", sep = "")
    },
    content = function(file) {
      writexl::write_xlsx(scoring_summary_data(), path = file)
    }
  )
  
  # Dynamic UI for scoring parameters based on selected MDS variables
  output$scoring_params_ui <- renderUI({
    req(mds_vars_selected())
    
    lapply(mds_vars_selected(), function(var) {
      wellPanel(
        h4(paste("Scoring for:", var)),
        selectInput(paste0("score_type_", var), "Scoring Function Type:",
                    choices = c("More is Better" = "more_is_better",
                                "Less is Better" = "less_is_better",
                                "Optimum Range" = "optimum_range")),
        uiOutput(paste0("params_for_", var))
      )
    })
  })
  
  # Dynamic UI for parameters of each scoring type
  observe({
    req(mds_vars_selected())
    lapply(mds_vars_selected(), function(var) {
      output[[paste0("params_for_", var)]] <- renderUI({
        score_type <- input[[paste0("score_type_", var)]]
        if (is.null(score_type)) return(NULL)
        
        var_data <- data_raw()[[var]]
        mean_val <- mean(var_data, na.rm = TRUE)
        sd_val <- sd(var_data, na.rm = TRUE)
        
        if (score_type == "more_is_better") {
          fluidRow(
            column(6, numericInput(paste0("param_", var, "_x0"), "Inflection Point (x0):", value = round(mean_val, 2), step = 0.1)),
            column(6, numericInput(paste0("param_", var, "_b"), "Slope (b):", value = 2.5, min = 0.1, step = 0.1))
          )
        } else if (score_type == "less_is_better") {
          fluidRow(
            column(6, numericInput(paste0("param_", var, "_x0"), "Inflection Point (x0):", value = round(mean_val, 2), step = 0.1)),
            column(6, numericInput(paste0("param_", var, "_b"), "Slope (b):", value = 2.5, min = 0.1, step = 0.1))
          )
        } else if (score_type == "optimum_range") {
          fluidRow(
            column(4, numericInput(paste0("param_", var, "_opt_val"), "Optimum Value:", value = round(mean_val, 2), step = 0.1)),
            column(4, numericInput(paste0("param_", var, "_width"), "Width:", value = round(sd_val / 2, 2), min = 0.01, step = 0.01))
          )
        }
      })
    })
  })
  
  # Reactive for calculated SQI and individual scores
  calculated_sqi_data <- eventReactive(input$calculate_sqi, {
    req(data_raw(), mds_vars_selected(), pca_results())
    
    df_original <- data_raw()
    mds_vars <- mds_vars_selected()
    
    scores_df_numeric_only <- df_original %>% select(where(is.numeric))
    
    # 1. Calculate Individual Scores (Non-Linear)
    for (var in mds_vars) {
      score_type <- input[[paste0("score_type_", var)]]
      if (is.null(score_type) || !(var %in% names(scores_df_numeric_only))) {
        showNotification(paste("Error: Scoring parameters or numeric column missing for:", var), type = "error")
        return(NULL)
      }
      
      if (score_type == "more_is_better") {
        x0 <- input[[paste0("param_", var, "_x0")]]
        b <- input[[paste0("param_", var, "_b")]]
        scores_df_numeric_only[[paste0(var, "_Score")]] <- score_more_is_better(scores_df_numeric_only[[var]], x0, b)
      } else if (score_type == "less_is_better") {
        x0 <- input[[paste0("param_", var, "_x0")]]
        b <- input[[paste0("param_", var, "_b")]]
        scores_df_numeric_only[[paste0(var, "_Score")]] <- score_less_is_better(scores_df_numeric_only[[var]], x0, b)
      } else if (score_type == "optimum_range") {
        opt_val <- input[[paste0("param_", var, "_opt_val")]]
        width <- input[[paste0("param_", var, "_width")]]
        scores_df_numeric_only[[paste0(var, "_Score")]] <- score_optimum_range(scores_df_numeric_only[[var]], opt_val, width)
      }
    }
    
    # 2. Calculate Weights based on PCA Communalities (as per paper)
    pca_res <- pca_results()
    var_loadings_matrix <- pca_res$var$coord # All loadings
    
    eigenvalues <- pca_res$eig[, "eigenvalue"]
    significant_pc_indices <- which(eigenvalues >= 1)
    
    if (length(significant_pc_indices) == 0) {
      showNotification("No significant principal components (Eigenvalue >= 1) found. Cannot calculate weights. Please review PCA results.", type = "error")
      return(NULL)
    }
    
    communalities <- sapply(mds_vars, function(v) {
      if (v %in% rownames(var_loadings_matrix)) {
        if (length(significant_pc_indices) > 0) {
          sum(var_loadings_matrix[v, significant_pc_indices]^2)
        } else {
          0
        }
      } else {
        0
      }
    })
    
    total_communalities <- sum(communalities)
    if (total_communalities == 0) {
      showNotification("Sum of communalities is zero for selected MDS indicators. Cannot calculate weights. Check MDS selection.", type = "error")
      return(NULL)
    }
    weights <- communalities / total_communalities
    
    # Determine which PC has the highest absolute loading for each selected MDS variable
    pc_map_df <- tibble(Indicator = mds_vars, Highest_Loading_PC = character(length(mds_vars)))
    
    for (i in seq_along(mds_vars)) {
      var_name <- mds_vars[i]
      if (var_name %in% rownames(var_loadings_matrix)) {
        loadings_for_var <- var_loadings_matrix[var_name, significant_pc_indices, drop = FALSE]
        
        if (length(loadings_for_var) > 0) {
          highest_pc_index <- which.max(abs(loadings_for_var))
          highest_pc_name <- colnames(loadings_for_var)[highest_pc_index]
          pc_map_df$Highest_Loading_PC[i] <- highest_pc_name
        } else {
          pc_map_df$Highest_Loading_PC[i] <- "N/A"
        }
      } else {
        pc_map_df$Highest_Loading_PC[i] <- "N/A"
      }
    }
    
    # Create the final MDS weights data frame with the new column
    mds_weights_df <- tibble(
      Indicator = mds_vars,
      Highest_Loading_PC = pc_map_df$Highest_Loading_PC,
      Communalities = communalities,
      Weight = weights
    )
    
    # 3. Calculate SQI
    temp_sqi_calc_df <- scores_df_numeric_only %>%
      select(all_of(mds_vars))
    
    temp_sqi_calc_df$SQI_temp <- 0
    
    for (i in seq_along(mds_vars)) {
      var_name <- mds_vars[i]
      weight_val <- weights[i]
      score_col_name <- paste0(var_name, "_Score")
      if (score_col_name %in% names(scores_df_numeric_only)) {
        temp_sqi_calc_df$SQI_temp <- temp_sqi_calc_df$SQI_temp + (scores_df_numeric_only[[score_col_name]] * weight_val)
      } else {
        showNotification(paste("Warning: Score column not found for", var_name, ". Skipping calculation for this indicator."), type = "warning")
      }
    }
    
    all_final_cols <- df_original %>%
      bind_cols(scores_df_numeric_only %>% select(starts_with(paste0(mds_vars, "_Score")))) %>%
      mutate(SQI = temp_sqi_calc_df$SQI_temp * 100)
    
    list(
      sqi_data = all_final_cols,
      mds_weights = mds_weights_df
    )
  })
  
  # Display SQI Results Table
  output$sqi_results_table <- renderDT({
    req(calculated_sqi_data()$sqi_data)
    calculated_sqi_data()$sqi_data
  }, options = list(pageLength = 10))
  
  # Display MDS Weights Table
  output$mds_weights_table <- renderDT({
    req(calculated_sqi_data()$mds_weights)
    calculated_sqi_data()$mds_weights
  }, options = list(dom = 't'))
  
  # Download Handler for MDS Weights Table (.xlsx)
  output$download_mds_weights <- downloadHandler(
    filename = function() {
      paste("mds_weights_table_", Sys.Date(), ".xlsx", sep = "")
    },
    content = function(file) {
      req(calculated_sqi_data()$mds_weights)
      writexl::write_xlsx(calculated_sqi_data()$mds_weights, path = file)
    }
  )
  
  # Render SQI Histogram
  output$sqi_histogram_plot <- renderPlot({
    req(calculated_sqi_data()$sqi_data)
    ggplot(calculated_sqi_data()$sqi_data, aes(x = SQI)) +
      geom_histogram(binwidth = 5, fill = "steelblue", color = "black") +
      labs(title = "Distribution of Soil Quality Index (0-100)", x = "Soil Quality Index", y = "Frequency") +
      theme_minimal()
  })
  
  # Dynamic UI for selecting grouping variable
  output$grouping_variable_selector_ui <- renderUI({
    req(data_raw())
    non_numeric_cols <- names(data_raw() %>% select(where(~!is.numeric(.))))
    
    if (length(non_numeric_cols) == 0) {
      return(p("No non-numeric columns found in your data to group by."))
    }
    
    selectInput("group_var_for_plot", "Select Grouping Variable for SQI Bar Graph:",
                choices = c("None" = "", non_numeric_cols),
                selected = "")
  })
  
  # Render Grouped SQI Bar Plot
  output$sqi_group_bar_plot <- renderPlot({
    req(calculated_sqi_data()$sqi_data)
    
    group_var <- input$group_var_for_plot
    
    if (is.null(group_var) || group_var == "") {
      return(
        ggplot() +
          geom_text(aes(x = 0.5, y = 0.5, label = "Select a grouping variable to view the bar graph")) +
          theme_void() +
          labs(title = "SQI Grouped Bar Graph")
      )
    }
    
    plot_data <- calculated_sqi_data()$sqi_data %>%
      mutate(!!sym(group_var) := as.factor(!!sym(group_var))) %>%
      group_by(!!sym(group_var)) %>%
      summarise(Mean_SQI = mean(SQI, na.rm = TRUE),
                SD_SQI = sd(SQI, na.rm = TRUE)) %>%
      ungroup()
    
    ggplot(plot_data, aes(x = !!sym(group_var), y = Mean_SQI)) +
      geom_bar(stat = "identity", fill = "gray80", color = "black") +
      geom_errorbar(aes(ymin = Mean_SQI - SD_SQI, ymax = Mean_SQI + SD_SQI), width = 0.2, position = position_dodge(.9)) +
      labs(title = paste("Mean Soil Quality Index (0-100) by", group_var),
           x = group_var,
           y = "Mean Soil Quality Index (0-100)") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1),
            plot.margin = unit(c(1, 4, 1, 1), "lines")) +
      
      geom_hline(yintercept = 80, linetype = "dashed", color = "black", linewidth = 0.8) +
      geom_hline(yintercept = 60, linetype = "dashed", color = "black", linewidth = 0.8) +
      geom_hline(yintercept = 40, linetype = "dashed", color = "black", linewidth = 0.8) +
      geom_hline(yintercept = 20, linetype = "dashed", color = "black", linewidth = 0.8) +
      
      annotate("text", x = Inf, y = 80, label = "Q1: Extremely High (80-100)",
               hjust = 1.1, vjust = -0.5, size = 3, color = "darkgreen") +
      annotate("text", x = Inf, y = 60, label = "Q2: High (60-80)",
               hjust = 1.1, vjust = -0.5, size = 3, color = "forestgreen") +
      annotate("text", x = Inf, y = 40, label = "Q3: Medium (40-60)",
               hjust = 1.1, vjust = -0.5, size = 3, color = "orange") +
      annotate("text", x = Inf, y = 20, label = "Q4: Poor (20-40)",
               hjust = 1.1, vjust = -0.5, size = 3, color = "firebrick") +
      annotate("text", x = Inf, y = 0, label = "Q5: Extremely Poor (0-20)",
               hjust = 1.1, vjust = -0.5, size = 3, color = "darkred") +
      
      coord_cartesian(ylim = c(0, 100), clip = "off")
  })
  
  # Reactive for Grouped SQI Summary Table
  sqi_group_summary_table <- reactive({
    req(calculated_sqi_data()$sqi_data)
    group_var <- input$group_var_for_plot
    
    if (is.null(group_var) || group_var == "") {
      return(data.frame(Message = "Please select a grouping variable to view this table."))
    }
    
    calculated_sqi_data()$sqi_data %>%
      mutate(!!sym(group_var) := as.factor(!!sym(group_var))) %>%
      group_by(!!sym(group_var)) %>%
      summarise(
        N = n(),
        Mean_SQI = mean(SQI, na.rm = TRUE),
        SD_SQI = sd(SQI, na.rm = TRUE)
      ) %>%
      ungroup() %>%
      rename(Group = !!sym(group_var))
  })
  
  # Render Grouped SQI Summary Table
  output$sqi_group_summary_table <- renderDT({
    req(sqi_group_summary_table())
    datatable(sqi_group_summary_table(), options = list(dom = 't'))
  })
  
  # Download Handler for SQI Results
  output$download_sqi <- downloadHandler(
    filename = function() {
      paste("sqi_results_", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      write_csv(calculated_sqi_data()$sqi_data, file)
    }
  )
}

# Run the app
shinyApp(ui, server)
